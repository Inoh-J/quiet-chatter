# 오픈미션 회고

*2025-11*

**막막한 감정의 너머**

이번 오픈미션에 대한 설명을 듣고나서 막막한 감정을 마주하고 말았다. 아마 지난 3주간 구체적인 문제와 제약조건이 있는 상황에 익숙해진 탓도 있으리라 생각했다.

<img alt="한강의 풍경" height="400" src="img/20251101_한강의풍경.jpg" width="700"/>

얼마전 한강으로 산책을 나갔다가 눈앞의 탁 트인 풍경에 어지러움을 느꼈다. 지난 주차까지 밤낮으로 모니터만 보던 나의 눈이 손을 뻗으면 닿을 정도의 거리감 정도에만 익숙해서 적응을 하지 못한 까닭이었다. 나는 둔치에 잠시 앉아서 숨을 고르며 어지러움증이 잦아들 때까지 기다렸다. 시월의 한강은 구름 한점 없는 하늘 만큼이나 청명했고 한껏 빛을 머금은 윤슬은 무척 생기가 가득했다.

생각해보면 세상은 원래 광활한 편이었다. 문밖은 작은 새소리와 아이들의 웃음소리가 발 디딜 틈 없이 일렁대는 곳이었고, 지하철 역 앞 정류소는 헤아릴 없을 만큼 무수한 감정들이 눈빛 너머로 지나쳐가는 곳이었다. 내가 잠시 잊고 있던 것처럼, 내가 걸음을 멈춘다고해서 행인들은 걸음을 멈추지 않을 것이고 내가 설령 우아한 테크코스에 합격했다고 한들 수료 직후의 내게 한강의 풍경은 지금과 같을 것이라고 생각했다.

그래서 나는 마음을 달리 먹어야겠다고 생각했다. 손에 잡힐듯한 성취에 스스로의 눈을 멀게하고 싶지 않았다. 이번 오픈 미션이 마감을 끝으로 소모되는 단발의 총성이 아니라, 매일 울리는 풍경(風磬)이 되어 생애의 운율로 남았으면 했다. 그래서 지속 가능하고 자족 가능한 성장을 위해서 어떤 것에 마음을 쏟아야 할지를 고민했다. 이러한 생각은 꼬리에 꼬리를 물었고 결국 실제로는 중요하지 않았던 것들을 위시한다며 서랍안에 접어 두었던 생애의 의문을 돌이켜 보게끔 나의 마음을 움직였다.

나는 특정한 주제로 사람을 연결하는 일에 줄곧 흥미를 느껴왔다. 독서모임과 개발 스터디의 시작도 그런 차원에서의 시도였다. 모임을 운영하며 나름의 보람이 있었지만 많은 사람들이 스스로의 능력을 과소평가하고 본인을 드러내기 쑥스러워 하는 까닭에 모임의 문턱 앞에서 돌아갔던 기억들이 여전히 마음 한켠에 숙제처럼 남아있었다. 아마도 '나는 이곳에 어울리지 않아' 같은 내적인 속삭임으로 대변될 수 있을 그 마음들을 생각하면서, 이 문제를 해결하기 위한 시도으로써 이번 오픈 미션을 시작해보면 좋겠다고 생각했다. 그리고 그 미션의 결과물이 '너는 이곳에 어울려' 라는 메세지를 전달해줄 수 있길 원했다.

그래서 나는 수줍음이 많은 사람들을 위한 독서모임 애플리케이션을 만드는 것을 이번 오픈미션 과제로 정했다. 이름은 `Quiet Chatter: You Belong Here`로 정했다. 익명으로 자신을 드러내지 않고 책에 대한 감상을 나누고 좋아요과 공감한다는 반응을 나누게 하면 편안함늘 느낌을 주지 않을까 생각했다. 자신이 글이 영원히 인터넷에 박제될 수 있다는 두려움을 없애기 위해서 시간이 지나면 자동으로 비공개되는 짧은 호흡의 독후감이나 생각을 나눌 수 있으면 좋겠다고 생각했다.

이 어플리케이션에 대한 소개는 [README.md](/README.md)에 적어두었다.

---

**프리코스와 오픈미션**

나는 본 프로젝트가 장차 틀을 깨고 달려나가더라도 지난 3주동안의 프리코스의 과정이 녹아 들어가기를 원했다. 다시말해 본 프로젝트에서 내가 배운 것들을 그대로 응용함으로써 그간의 배움의 과정이 확장되기를 원했다.

그래서 멋진 새 기술이나 언어를 사용해서 화려한 모습을 보이는 것보다 익숙한 기술을 사용하더라도 본 프로젝트를 설계하고 구현하는 디테일에 그간의 진정성을 담고 싶었다. 구체적으로는 나는 지난 3주간 집중했던 객체지향과 그 원칙(OOP & SOLID), 테스트 주도 개발(TDD), 클린코드(Clean Code), 확장가능한 설계 (DDD, 클린 아키텍쳐)를 그대로 녹여내고 싶었다.

하지만 이번 프로젝트를 도전하는데 있어서 새로운 기술의 도입은 필수불가결했다. 누구나 접속 가능한 애플리케이션을 만들기 위해서는 웹과 호스팅 기술이 필요했고 독후감을 남기고 저장하기 위해서는 UI와 데이터베이스 기술이 필요했다.

딜레마는 항상 있다. 그리고 한쪽을 선택하기 보다 중요한 것의 비중을 더 많이 가저가고 필요할 때마다 조정하는 것이 대게 좋은 결정이었던 것 같다. 그래서 새로운 기술의 도입은 최소화하기로 했다.

이러한 취지에 맞춰 언어는 프리코스에서 사용하던 그대로 Java 21을 사용하고 웹 애플리케이션 서버(WAS) 구동을 위해 대중적인 Spring Boot를 사용했다. 호스팅을 위해서 클라우드 서버로 AWS EC2 보다 단순한 LightSail을 사용했다. UI를 위해서 내게 어려운 React 대신 쉬운 ThymeLeaf로 대신하기로 했다. 데이터베이스는 다양한 데이터를 쉽게 담을 수 있는 PostgreSQL을 사용했고 접근기술로는 추상화가 잘된 Spring Data JPA를 도입했다. 추가적으로 통합과 배포(CI/CD)를 미리 설정해두고 신경쓰지 않기 위해서 GitAction과 Docker Compose 정도만 도입했다.

부대 기술을 정했으니 구체적으로 어떻게 이번 오픈미션에서 지난 프리코스에서 배운 것들을 적용할지 적어볼 필요가 있었다. 그래서 나는 다음과 같이 제한조건과 목표를 설정했다.

---

### 나의 오픈미션 목표

**목표:** 오픈미션 과제로 독서모임 애플리케이션 `Quiet Chatter`을 출시한다.

**제한 조건:**

- 지난 프리코스와 같이 [AngularJS Git Commit Message Conventions](https://gist.github.com/stephenparish/9941e89d80e2bc58a153)을 바탕으로 커밋메세지를 작성한다.
- 지난 프리코스와 같이 [Java Style Guide](/docs/development-guide/java_style_guide.md)을 준수한다.
- [클린코드 원칙](/docs/development-guide/clean_code_principles.md)을 가능한 준수한다.
- 지난 프리코스 [1주](/docs/development-guide/week-1-feedback.md), [2주](/docs/development-guide/week-2-feedback.md), [3주](/docs/development-guide/week-3-feedback.md)차 피드백을 준수한다. (아래 요약)
    - README.md를 상세히 작성한다, 기능 목록을 재검토, 업데이트한다
    - 커밋 메시지를 의미 있게 작성한다
    - Java에서 제공하는 API를 적극 활용한다
    - 오류를 찾을 때 출력 함수 대신 디버거를 사용한다
    - 공백을 의미 있게 사용한다, 의미 없는 주석을 달지 않는다
    - 이름을 통해 의도를 드러낸다, 이름에 자료형을 사용하거나 축약하지 않는다
    - 객체의 상태 접근을 제한한다, 데이터를 꺼내지(get)않고 일하도록 한다
    - 값을 하드 코딩하지 않는다, 상수, 멤버 변수, 생성자, 메서드의 순서를 지킨다
    - 필드(인스턴스 변수)의 수를 줄이기 위해 노력한다
    - 연관성이 있는 상수는 static final 대신 enum을 활용한다
    - 메서드가 한 가지 기능만 수행하게 한다, 15라인이 넘지 않도록 구현한다.
    - 테스트의 이유를 @DisplayName에 작성한다, 작은 단위의 테스트를 먼저 작성한다, 예외 케이스도 테스트한다
    - 테스트를 구현 코드에서 분리한다, 테스트가 어려운 코드를 쉽게 만든다. 테스트를 위해 클래스 분리를 고려한다
    - 비즈니스 로직과 UI 로직의 분리한다

**도전할 것**

- 꼭 필요한 기술이 아니면 도입하지 않는다. 도입한 기술이 있다면 그 이유를 명확히 작성한다.
- 스스로 지난 3주차 동안 배운 것을 적극 적용한다.
    - TDD로 개발한다. 테스트 없이 프로덕트 코드를 만들지 않는다
    - 원시값을 도메인 의미가 있는 값객체(Value Object)로 감싸서 사용한다
    - 기능(function)과 기능(feature)을 구분하여 기능(function)에 대한 단위 테스트를 작성하고 이를 기능(feature)으로 묶어 의도를 드러낸다
    - 단위 테스트와 더불어 통합 테스트(전체 스프링을 가동한 API 테스트)를 작성한다
    - 객체간의 의존성을 인터페이스를 통해서 느슨하게 만든다
    - 비지니스를 녹여내기 위해서는 일급콜렉션 사용한다
    - 객체의 불변성과 가변성을 맥락에 맞도록 사용한다. 값-> 불변, 엔티티-> 가변
    - 테스트가 어려운 의존은 모킹하여 테스트한다, 외부 API나 확률을 모킹한다
    - 객체의 상태를 확인하지않고 일을 시킨다
    - 저수준의 도메인 모델을 집약하여 고수준의 도메인 모델을 만든다
    - 계층사이의 의존의 방향이 외부(어댑터)에서 내부(도메인)으로 흐르게 정렬한다

---

**프로젝트 빌드와 첫 스프린트(2025-11-06 TH)**

본 프로젝트를 실행하기에 앞서 나는 단순히 흐릿한 아이디어만 있었고 사전에 준비해온 것이 전혀 없었기 때문에 즉각적인 설계와 발맞춘 개발이 필요했다. 그래서 나는 점진적 개발 모델을 통해서 개발을 수행해야겠다고 생각했다. 처음부터 모든 것을 설계하지 않고 작은 배포 단위로 반복적으로 기획 - 설계 - 구현을 반복하고자 했다.

나는 6일 새벽에 프로젝트 초기 세팅과 아주 간단한 요구사항 작성을 끝내고 깃허브에 첫 푸쉬를 했다. 점진적인 개발을 위해서 일정 간격으로 스프린트를 진행할 예정이다. 오늘부터 작업을 시작해서 현재까지의 다음 배포를 7일에 수행하기로 했다.

```mermaid
---
displayMode: compact
---
gantt
    axisFormat %m-%d
    title 스프린트 일정표
    dateFormat MM-DD
    section 구현-배포
        스프린트1: 11-06, 2d
        스프린트2: 11-09, 2d
        스프린트3: 11-12, 2d
        스프린트4: 11-15, 2d
    section 회고
        준비: 11-08, 1d
        준비: 11-11, 1d
        준비: 11-14, 1d
        제출: 11-17, 1d
```

---

**1회차 스프린트 작업 part 1**

- 최소한의 CICD 구축
    -[x] 깃허브 저장소에 시크릿 등록
    - [x] AWS Light Sail 인스턴스 생성
    - [x] 프로젝트 Dokcerfile 작성
    - [x] 깃 액션 배포 스크립트 작성

나는 통합과 배포(CI/CD)를 미리 설정해두고 신경쓰지 않기 위해서 깃허브 액션을 도입하여 최소한의 CI/CD 워크플로우를 도입했다. 나는 스크립트 작성을 못하지만 이 부분은 LLM의 많은 도움을 받았다.

배포방법에 대한 고민도 했는데 jar로 배포하는 것보다 도커로 이미지 단위로 배포하는 것이 따로 서버에 JDK와 같은 필요한 의존성을 따로 관리할 필요가 없어 유리하다고 생각했다. 그래서 통합단계에서 도커이미지를 Push하고 인스턴스에서 직접 Pull해서 Docker Compose로 실행하는 방식을 택했다. 또한 컨테이너 가동에 필요한 환경변수는 서버쪽에서 가지고 있는게 좋겠다는 판단을 했다. docker-compose.yml에 서버와 db에 대한 정보를 작성하고 환경변수도 미리 작성하여 가동했다.

서버를 외부로 공개하기 위해서 클라우드 서비스로 AWS Light Sail을 서버 인스턴스로 적용했다. 이에 대한 별다른 지식이 없는터라 가장 저렴한 Light Sail의 인스턴스를 고르고 말았는데 여유 메모리가 너무 작아 DB를 이미지로 설치하다가 서버가 터지고 말았다. 나중에 사양이 낮아 가용 메모리가 부족했던 사실을 알고나서 더 높은 스펙의 인스턴스를 생성했다. 다음부터는 꼭 실행할 앱의 필요한 메모리를 사전에 계산해야겠다고 생각했다.

![프로젝트_CI_첫성공_2025-11-06.png](img/프로젝트_CI_첫성공_2025-11-06.png)
![프로젝트_첫배포_2025-11-06.png](img/프로젝트_첫배포_2025-11-06.png)
![서버_실행로그_2025-11-06.png](img/서버_실행로그_2025-11-06.png)

최소한의 인프라만 구축하려고 했는데 생각보다 부대 작업에 시간이 무척 많이 소요된 것 같다. 아무쪼록 열심히 씨름한 끝에 결국 첫 배포를 완료하였다 :)

---

**1회차 스프린트 작업 part 2**

- 도메인 표현 기술 설계
    - [x] 엔티티 기본 구조(아이디, 필드 타입) 설계
- 테스트 환경설정
    - [x] 테스트 컨테이너 설정

본격적으로 바로 도메인 모델 구축 작업을 하려고 시도했으나 막상 시작하려고하니 여러 설계적인 고민 때문에 바로 작업에 들어가지 못하고 깊은 공부가 필요했다.

처음 고민했던 부분은 엔티티의 ID 필드를 어떻게 정의할 것인지였다. 보통 많이 사용하는 Long 타입은 엔티티의 ID를 담는 타입으로 쓰기엔 도메인 표현력이 부족했다. 그래서 UUID를 공통 Id 타입으로 두는 것과 직접 엔티티마다의 Id 클래스를 두는 것 사이에서 고민해야했다. UUID의 통용성과 편의성을 선택할지, 각 클래스마다 컨버터 구현이 필요하더라도 도메인 표현성을 높기 위해 Id 클래스를 도입할지에 대한 고민을 하면서 결국 UUID 클래스를 도입하기로 마음 먹었다. UUID는 자바 표준이고 Long 타입보다 표현력이 좋으면서 또한 여러 다른 DB를 사용하더라도 별다른 변경없이 사용이 가능해서 차용했다. 도메인 계층은 확실히 Id라는 모델에 대한 표현력이 좋아지기를 기대했다.

나는 PostgreSQL를 사용했고 로컬 테스트에서도 데이터베이스와 통합된 테스트를 하고 싶었다. 그래서 추가적으로 [학습](https://java.testcontainers.org/modules/databases/jdbc/)을 통해 테스트 컨테이너를 도입하게 되었다. 그리고 제대로된 쿼리가 나갔는지 확인하기 위한 로깅레벨 설정과 테스트 프로파일 설정도 함께 익히게 되었다.

---

**1회차 스프린트 회고 **  
1회차에서는 본격적으로 프로젝트를 수행하기 위한 빌드, 배포, 테스트 준비 작업이 주를 이루었다. 스프린트를 시작하기에 앞서 최소한의 인프라만 기술과 구축하려고 했는데 생각보다 고려해야할 것도 많고 시행착오도 많았다. 막상 속도를 위해서 최소한의 기술을 도입하려고 했지만 공부를 하다보니 관련 기술이나 좀더 깊게 기술을 다루는 것에 흥미가 생겨서 종종 검색의 삼천포에 빠지기도 했다.

예를 들어 보안을 위해 프라이빗 서브넷을 깔고 프라이빗 서버로 이중화하기, 향후 요청을 캐싱하기 위해 Redis 도입할지, 지금처럼 ThymeLeaf로 서버사이드 렌더링이 아니라 따로 웹서버를 둘지, 보안을 위해서 JWT 방식을 도입할지 같은 것들이다. 1회차 내내 이런 유혹에 시달렸지만 결국 떨처낼 수 있었다.

언급한 기술들은 필요할 것들이고 좋은 기술들이지만 건축으로 따지자면 난방시스템, 보안시스템, 조명시스템 같은 것이라고 생각한다. 아직 집이 지어지지도 않고 사람이 들어와 살지 않는데 이런 것들을 일찍 생각하다보면 사공많은 배가 산으로 가는 것처럼 프로젝트가 진척되지 않을 것이라고 생각했다. 신경이 쓰이는 것은 사실이지만 의도적으로 넘어가는 연습이 필요한 것 같다는 생각이 든다. 서비스를 만드는데 있어서 정말 중요한 것은 사용할 수 있는 서비스를 만드는 일이다.

우아한 테크코스 프리코스 마지막에 있는 최종 코딩 테스트에 대한 얘기들이 생각이 났다. '안돌아가는 프로그램보다 돌아가는 쓰레기를 만들라'는 말처럼 우리가 아는 것을 모두 고려하는 것이 현실적으로 불가능할 때가 많고 중요한 것을 먼저 생각하고 합리적으로 선택해야겠다고 생각하게 되었다.

비단 개발에서만이 아니라 실생활에서도 적용이 되는 말이기도 하다. 나는 지금 필요하지 않은 것들을 생각하고 걱정하느라 지금 해야할 것들을 놓치고 있지는 않을까 반성하게 되었다. 인생에 있어서 우선순위는 거듭해서 스스로 상기하지 않으면 쉽게 질서를 잃어버린다. 내가 그간 신경쓰지 못한 게 무엇일까 생각하다가 이참에 부모님에게 안부전화를 드렸다. 전화기 너머로 현재 우테코 지원에 집중하느라 무직인 내 상황에 대해 걱정과 애정이 섞인 잔소리를 들었지만 기분은 좋았다.

어느덧 시간이 흘러 단풍이 예쁘게 물들고 있었다. 돌이켜본다면 어떤 일을 붙잡고 있느라 계절의 변화를 느껴보지 못했던 적이 종종 있었던 것 같다. 중요한 일이었을 수도 있고 그 때 열심히 하지 않았더라면 지금의 나는 없을 수도 있다. 그래도 확실한 사실은 그 시절의 벚꽃을 볼 정도의 물리적인 여유는 충분했다는 것이다. 다만 이완없는 긴장으로 인해 그럴 생각을 못했던 것 같다. 좋은 풍경은 휴식을 주지만 의도적으로 그런 환경에 머물지 않는다면 휴식을 찾기 어렵겠구나 생각했다.

<img alt="20251107_산책가는길의단풍.jpg" height="400" src="/docs/img/20251107_산책가는길의단풍.jpg" width="400"/>

환경은 그곳에 머무는 사람에게 영향을 준다. 만약 우테코에 합격한다면 우테코라는 환경은 내게 어떤 영향을 줄까? 가능성은 뒤로한채 잠깐 상상해보기도 했다.


---

**2회차 스프린트 작업**

**외부 API를 테스트하기: 네이버 검색 **

학습을 통해서 [네이버 개발자 센터에서 책은 검색할 수 있는 API](https://developers.naver.com/docs/serviceapi/search/book/book.md#%EC%B1%85)를 발견하고 사용등록을 했다. API를 사용하는 것은 어렵지 않았다. 다만 외부 API를 테스트 코드에 적용해본 적이 없어서 많은 시행착오를 겪었다.

우선 외부 API는 시간과 비용이 많이 들기 때문에 이를 테스트 하는 것은 기존 단위테스트와는 분리해야했다. 그래서 [org.junit.jupiter.api.Tag를 사용하여 gradle 테스트 테스크에서 제외하는 방법](https://random-topic.tistory.com/190)을 공부하게 되었고 이를 빌드 스크립트에 분리시켰다. 테스트 코드에서는 외부 API 테스트가 필요한 경우에만 `@Tag("external-api")`만 붙였다.

추가로 외부 API 테스트에 필요한 API 키는 보안을 위해서 프로퍼티로 로컬 테스트에서 주입시키는 방법을 알게되었다. `gradle.properties`에서 해당 프로퍼티가 정의되어 있지 않으면 예외를 던지므로 편하게 테스트가 가능했다. Gradle 빌드 스크립트는 내게 익숙치 않았는데 이참에 조금 공부할 수 있어서 좋았다.

```groovy
//build.gradle
tasks.named('test', Test) {
    useJUnitPlatform()
    useJUnitPlatform {
        excludeTags("external-api")
    }
}

tasks.register("testExternalApi", Test) {
    group = "verification"
    description = "외부 API 테스트"

    useJUnitPlatform {
        includeTags("external-api")
    }

    def naverApiClientIdName = 'naver.api.client-id'
    def naverApiClientSecretName = 'naver.api.client-secret'

    systemProperty naverApiClientIdName, project.property(naverApiClientIdName)
    systemProperty naverApiClientSecretName, project.property(naverApiClientSecretName)
}
```

그다음 집중한 것은 외부 API를 모킹하는 테스트이다. 이부분도 경험이 없어서 [검색](https://www.baeldung.com/restclienttest-in-spring-boot)을 통해서 `@RestClientTest`를 사용하면 테스트 클래스에서 간편히 Mock서버를 빈으로 등록할 수 있고 이를 가져와 테스트 할 수 있다는 사실을 알았다.

그래서 나는 네이버 검색 API를 사용하는 빈(NaverBookSearcher.class)가 생성자에서 `RestClient`가 아니라 `RestClient.Builder`를 의존하여 주입받도록 변경했다. 네이버 검색 API를 사용하는 빈(NaverBookSearcher.class)은 해당 빌더를 받아서 필요한 디폴트 URL과 해더를 설정하여 `build()`를 호출하여 직접 `RestClient`를 만들도록 했다.

`@RestClientTest`을 사용하여 테스트에서 전달받는 `RestClient.Builder`을 목서버로 모킹하도록 설정했다. 목서버에 바인딩된 `RestClient.Builder`를 통해 생성된  `RestClient`는 자동으로 목서버와 통신하도록 작동하는 것을 배웠다. 작성된 코드의 예시는 아래와 같다.

```java

@RestClientTest(NaverBookSearcher.class)
class NaverBookSearcherTest {
    @Autowired
    private NaverBookSearcher naverBookSearcher;

    @Autowired
    MockRestServiceServer mockServer;

    @MockitoBean
    private NaverApiEnvironment naverApiEnvironment;

    @Test
    @DisplayName("API 모킹 단위 테스트")
    void findByKeywordMockedApi() {
        mockServer.expect(ExpectedCount.once(), MockRestRequestMatchers.anything())
                .andRespond(withSuccess(
                        """
                                {
                                    "total": 1,
                                    "start": 1,
                                    "display": 1,
                                    "items": [
                                        {
                                            "title": "수레바퀴 아래서",
                                            "isbn": "9788937460500"
                                        }
                                    ]
                                }""",
                        MediaType.APPLICATION_JSON
                ));

        Keyword keyword = new Keyword("수레바퀴 아래서");
        PageRequest pageRequest = PageRequest.of(0, 10);

        Page<Book> books = naverBookSearcher.findByKeyword(keyword, pageRequest);

        assertThat(books.getTotalElements()).isEqualTo(1);
        assertThat(books.getContent()).isNotEmpty();

        assertThat(books.getContent()).allSatisfy(book -> assertThat(book.getIsbn()).isNotNull());
    }
}
```

이번 공부를 통해서 다음부터 외부 API를 모킹하는 테스트를 더욱 자신감 있게 작성할 것 같다는 예감이 든다.

